---
title: "JavaScriptの非同期処理のメモ"
postdate: "2099-01-01"
updatedate: "2099-01-01"
seriesName: "JavaScript 非同期処理を学ぶ"
seriesSlug: "JSAsync"
description: ""
tags: ["JavaScript", "非同期処理"]
---

# JavaScriptの非同期処理を学ぶ

JavaScriptの初学者を悩ませる鬼門として**非同期処理**が挙げられます。

コールバック、`Promise`、`async/await`を一通り勉強すれば書けないこともないのですが、その裏側の仕組みまで知ろうとするとかなり大変です。普通の入門書ではその辺まで扱っていませんからね。

**JavaScript中級者を目指す**というシリーズでも非同期処理には言及していますが、私自身の理解が今一つ曖昧だったため、詳細を記述することが出来ませんでした。

出来るだけハンズオン形式にしたかったのですが、どうしても読み物チックになってしまうと思います。ご了承ください。

# 同期処理と非同期処理

まずはこの用語の違いをちゃんと認識する必要があります。

同期処理は**コードを順番に処理していきます**。あるコードの実行が開始されれば、その実行が終わるまでは次のコードの処理は始まりません。

以下のコードは同期処理の例です。

```javascript
consoel.log(1);
consoel.log(2);
consoel.log(3);
```

何の変哲もないコードですが、これが同期処理の例です。出力結果は、、、分かりますね？

```console
1
2
3
```

上に書いたものから順番に処理されていきます。

次に非同期処理の例を見てみます。恐らく非同期処理について調べたことのある人なら1000回くらい目撃している例です（見飽きたとか言わないでください）。

```javascript
console.log(1)

setTimeout(() => {
  console.log(2)
}, 1000)

console.log(3)
```

やりたいことは以下の通りです。

1. コンソールに`1`を出力する
2. `1`が出力されてから**1秒後に**`2`を出力する
3. `2`が出力されてからすぐ`3`を出力する

ここで`setTimeout`関数について簡単におさらいします。

第1引数には、タイマーが完了した後に実行したい関数を渡します。ここでは`console.log(2)`を実行する無名関数を渡しています。

そして第2引数で数値（ミリ秒）を渡し、タイマーの時間を設定します。ここでは`1000`を渡しているので、タイマーは1秒という事になります。

ということで、`setTimeout`を実行してから1秒経った後に`2`がコンソール出力されることになります。

で、上記で紹介したコードがどういう動きをするかというと、、、

```javascript
1
3
// 約1秒経ってから...
2
```

このように、意図した通りにコンソール出力されません。

詳しいことはこれから説明しますが、処理の流れを大雑把に解説します。

まずは**キュー**というものへの関数の登録が行われます。記述された順番通り、`log(1)`、`setTimeout()`、`log(3)`の順番でキューへの登録が行われます。**先入れ先出方式**をイメージしてください。

![](./images/image01.png)

まずは`log(1)`が実行され、`1`がコンソール出力されます。続いて`setTimeout()`が実行され、`log(2)`が**タイマーに登録されます**。続いて`log(3)`が実行され、`3`がコンソール出力されます。

そして、`log(2)`がタイマーに登録されてから1秒後に`log(2)`がキューに登録されます。これは登録されてからすぐに実行されますので、`2`がコンソール出力されます。

という流れを経て、`1`→`3`→`2`という、非同期処理を知らなければ意味不明な順番で処理されるのです。

この一連の流れの中で、「タイマーに`log(2)`を渡し、**先に`log(3)`を実行する**」という部分こそが非同期処理であると言えます。

## JavaScriptはシングルスレッド

なぜこんな**非同期処理**なるものが存在してるかというと、JavaScriptが**シングルスレッド**処理を行っているためです。

### スレッドって何？

そもそも**スレッド**とは、「処理が行われる流れ」です。(要修正)一つのスレッドでは、（同時に）一つの処理しか行えません。

シングルスレッドは名前の通り、「スレッド一つだけで処理を行っている」ということです。

下図で言うと右に向かっている矢印がスレッドだと捉えてください。プログラムの実行環境にスレッドは一つしか存在しておらず、`処理A`と`処理B`は**同時に**実行することができません。`処理A`が完了するのを待って`処理B`を処理することになります。

![](./images/image01.png)

これに対して**マルチスレッド**という処理方式もあります。スレッドが複数存在しており、それぞれのスレッドが別個に処理を行えます。

![](./images/image02.png)

これだけ見るとマルチスレッドの方が処理速度が速くて良さそうですが、

- 同期処理の難しさ（期待した順番通りに処理を行えるか？）
- スレッドの分だけCPUリソースを消費する

といったデメリットも存在します。なので一概にどちらの処理方式の方が優れている、などと論じれるものではありません。

JavaScriptは並列処理ができないということ。

仕組みとして、キューというものが存在します。そのキューに関数を登録していき、先入れ先出方式で順番に処理されていきます。でも、キューに登録する順番を工夫することで非同期処理を実現できます。

## まとめ

今回の内容を大雑把にまとめると以下のようになります。

- JavaScriptはシングルスレッドで実装されている
- シングルスレッドでも並列っぽく処理できるよう、**イベントループ**を採用している

最初はこの2点だけ押さえておけば十分ではないでしょうか。

## 参考

[非同期処理:コールバック/Promise/Async Function | #jsprimer](https://jsprimer.net/basic/async/)

[JavaScriptの同期、非同期、コールバック、プロミス辺りを整理してみる - Qiita](https://qiita.com/YoshikiNakamura/items/732ded26c85a7f771a27)

[【図解】1から学ぶ JavaScript の 非同期処理 - Qiita](https://qiita.com/ryosuketter/items/dd467f827c1b93a74d76)

[Node.jsの非同期I/Oについて調べてみた - Tech Blog - Recruit Engineer](https://engineer.recruit-lifestyle.co.jp/techblog/2019-12-13-node-async-io/)

[JavaScript のスレッド並列実行環境](https://nhiroki.jp/2017/12/10/javascript-parallel-processing)

[15分で理解するJavaScriptのイベントループ - Qiita](https://qiita.com/l1lhu1hu1/items/57dcc7cb867eee951f36)